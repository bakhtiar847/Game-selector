<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game Selector</title>
  <style>
    :root{--bg:#0f1720;--card:#0b1220;--accent:#5eead4;--muted:#94a3b8}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,#071023 0%,var(--bg) 100%);color:#e6eef6;min-height:100vh;display:flex;flex-direction:column}
    header{padding:28px 32px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:16px}
    h1{margin:0;font-size:20px}
  main{padding:28px;display:grid;grid-template-columns:1fr;gap:20px;align-items:start;max-width:900px;margin:0 auto}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .card h3{margin:0 0 8px 0;font-size:18px}
    .desc{color:var(--muted);font-size:14px;margin-bottom:12px}
  .controls{display:flex;gap:8px;align-items:center}
  .menu-btn{background:transparent;border:0;color:var(--muted);font-size:18px;padding:6px 8px;border-radius:6px;cursor:pointer}
  .menu{position:absolute;right:18px;top:48px;background:var(--card);border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:8px;box-shadow:0 8px 24px rgba(2,6,23,0.6);display:none;min-width:160px}
  .menu button{display:block;width:100%;text-align:left;background:transparent;border:0;color:var(--accent);padding:6px 8px;border-radius:6px;cursor:pointer}
  .badge-saved{background:#052b22;color:#9ff3d9;padding:4px 8px;border-radius:999px;font-size:12px;font-weight:600;margin-left:8px}
    button.play{background:var(--accent);color:#042;border:0;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
    button.open{background:transparent;color:var(--accent);border:1px solid rgba(94,234,212,0.12);padding:6px 10px;border-radius:8px;cursor:pointer}
    .empty{color:var(--muted);grid-column:1/-1;text-align:center;padding:40px}
    footer{margin-top:auto;padding:18px 28px;color:var(--muted);font-size:13px}
    @media (max-width:520px){main{padding:16px;grid-template-columns:1fr}header{padding:18px}}
    /* Sidebar/layout adjustments */
    #sidebar{overflow:auto}
    body.sidebar-collapsed #sidebar{width:64px}
    main#main-content{margin-left:220px;transition:margin .18s}
    body.sidebar-collapsed main#main-content{margin-left:64px}
    @media (max-width:700px){#sidebar{display:none} main#main-content{margin-left:0}}
  </style>
</head>
<body>
  <header>
    <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden><rect width="24" height="24" rx="6" fill="#052938"></rect><path d="M6 8h12v2H6zM6 12h12v2H6z" fill="#5eead4"/></svg>
    <h1>Game Selector</h1>
    <div id="userBox" style="margin-left:auto;display:flex;align-items:center;gap:8px">
      <span id="username-display" style="color:var(--muted);font-size:13px"></span>
    </div>
    <div id="multiplayerBox" style="margin-left:12px;display:flex;align-items:center;gap:8px">
      <button id="host-btn" class="open" title="Host (manual WebRTC)">Host</button>
      <button id="join-btn" class="open" title="Join (manual WebRTC)">Join</button>
      <button id="bluetooth-btn" class="open" title="Bluetooth (browser-to-browser Bluetooth is not available)">Bluetooth</button>
      <button id="open-chat" class="open">Chat</button>
      <button id="open-sample" class="play">Open Sample</button>
  <!-- Downloaded button removed from header (already available in sidebar navigation) -->
      <button id="add-game-btn" class="open" title="Add a game or gamelist">Add Game</button>
      <!-- export/import/change username controls moved to Settings panel -->
    </div>
  </header>


  <!-- Collapsible side panel navigation -->
  <aside id="sidebar" style="position:fixed;left:0;top:0;bottom:0;width:220px;padding-top:72px;background:var(--card);border-right:1px solid rgba(255,255,255,0.02);box-shadow:2px 0 24px rgba(2,6,23,0.4);transition:width .2s;z-index:40">
    <div style="position:absolute;top:12px;left:12px;right:12px;display:flex;align-items:center;justify-content:space-between">
      <strong>Menu</strong>
      <button id="sidebar-toggle" class="open" style="padding:6px 8px">≡</button>
    </div>
    <div style="display:flex;flex-direction:column;gap:6px;padding:8px">
      <button class="open" data-page="all" id="nav-all" style="text-align:left">All Games</button>
      <div>
        <button id="gamelists-toggle" class="open" style="text-align:left;width:100%">Gamelists ▾</button>
        <div id="gamelists-list" style="display:none;margin-top:6px;padding-left:8px;display:flex;flex-direction:column;gap:6px">
          <button class="open" id="gamelist-load-built" style="text-align:left">Built-in (gamelist.json)</button>
          <div style="display:flex;gap:6px;align-items:center">
            <button class="open" id="gamelists-add" style="flex:1;text-align:left">Add…</button>
          </div>
        </div>
      </div>
      <button class="open" data-page="downloaded" id="nav-downloaded" style="text-align:left">Downloaded</button>
      <button class="open" data-page="settings" id="nav-settings" style="text-align:left">Settings</button>
    </div>
  </aside>

  <!-- main content shifted to the right to allow for sidebar -->

  <!-- Username modal -->
  <div id="username-modal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);backdrop-filter:blur(4px);align-items:center;justify-content:center;z-index:60">
    <div style="background:var(--card);padding:20px;border-radius:12px;max-width:420px;width:90%;box-shadow:0 10px 40px rgba(2,6,23,0.7)">
      <h2 style="margin:0 0 8px 0">Welcome</h2>
      <p style="margin:0 0 12px;color:var(--muted)">Enter a display name that will be passed to games and saved for offline use.</p>
      <div style="display:flex;gap:8px">
        <div style="flex:1;display:flex;flex-direction:column;gap:8px">
          <input id="username-input" placeholder="Your name" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit">
          <input id="username-password" type="password" placeholder="Optional password to encrypt saved data" style="width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;font-size:13px">
        </div>
        <button id="save-username" class="play">Save</button>
      </div>
    </div>
  </div>

  <main id="main-content" style="padding:28px;max-width:900px;margin:0 auto;">
    <div id="page-all" style="display:block">
      <div id="list">
        <div class="empty">Loading games…</div>
      </div>
    </div>

    <div id="page-gamelists" style="display:none">
      <div class="card">
        <h3>Available gamelists</h3>
        <div id="gamelist-sources" style="display:flex;flex-direction:column;gap:8px;margin-top:12px"></div>
      </div>
    </div>

    <div id="page-downloaded" style="display:none">
      <div id="downloaded-list">
        <!-- downloaded games will be rendered here by showDownloadedView into the main list area -->
        <div class="empty">No downloaded games yet.</div>
      </div>
    </div>

    <div id="page-settings" style="display:none">
      <div class="card">
        <h3>Settings</h3>
        <div style="margin-top:12px;display:flex;flex-direction:column;gap:12px">
          <label><input type="checkbox" id="settings-encrypted"> Encrypted saved data active</label>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <button id="settings-export" class="open">Export cookies</button>
            <button id="export-cookies" class="open">Export (all)</button>
            <button id="import-cookies" class="open">Import cookies</button>
            <input id="import-file" type="file" accept="application/json" style="display:none">
            <button id="change-username" class="open">Change username</button>
            <button id="settings-clear" class="open">Clear saved data</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Signaling modal for manual offer/answer exchange -->
  <div id="signal-modal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);align-items:center;justify-content:center;z-index:70">
    <div style="background:var(--card);padding:18px;border-radius:12px;max-width:760px;width:92%">
      <h3 style="margin:0 0 8px 0">Connection signaling (manual)</h3>
      <div style="display:flex;gap:8px">
        <textarea id="signal-out" rows="6" style="flex:1;padding:8px;background:#00121a;color:#cfeef0;border-radius:8px;border:1px solid rgba(255,255,255,0.03)"></textarea>
        <textarea id="signal-in" rows="6" placeholder="Paste remote answer/offer here" style="flex:1;padding:8px;background:#00121a;color:#cfeef0;border-radius:8px;border:1px solid rgba(255,255,255,0.03)"></textarea>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px;justify-content:flex-end">
        <button id="signal-copy" class="open">Copy Out</button>
        <button id="signal-accept" class="play">Accept Remote</button>
        <button id="signal-close" class="open">Close</button>
      </div>
    </div>
  </div>

  <!-- Chat modal -->
  <div id="chat-modal" style="display:none;position:fixed;right:18px;bottom:18px;width:320px;z-index:80">
    <div style="background:var(--card);border-radius:12px;overflow:hidden;box-shadow:0 10px 40px rgba(2,6,23,0.6)">
      <div style="padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:space-between">
        <strong style="font-size:14px">Chat</strong>
        <button id="close-chat" class="open">Close</button>
      </div>
      <div id="chat-messages" style="height:260px;overflow:auto;padding:10px;background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent)"></div>
      <div style="display:flex;padding:8px;gap:8px;border-top:1px solid rgba(255,255,255,0.03)">
        <input id="chat-input" placeholder="Message" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit">
        <button id="chat-send" class="play">Send</button>
      </div>
    </div>
  </div>

  <!-- Sample multiplayer canvas modal -->
  <div id="sample-modal" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;z-index:85;background:rgba(2,6,23,0.6)">
    <div style="background:var(--card);padding:18px;border-radius:12px;max-width:900px;width:96%;box-shadow:0 12px 48px rgba(2,6,23,0.6);">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <h3 style="margin:0">Sample Multiplayer — Canvas</h3>
        <div>
          <button id="close-sample" class="open">Close</button>
        </div>
      </div>
      <div style="display:flex;gap:20px;align-items:center">

        <!-- Add / Upload modal: left = single game (file or URL), right = gamelist (file or URL) -->
        <div id="add-modal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);align-items:center;justify-content:center;z-index:90">
          <div style="background:var(--card);padding:18px;border-radius:12px;max-width:980px;width:96%;box-shadow:0 12px 48px rgba(2,6,23,0.6);display:grid;grid-template-columns:1fr 1fr;gap:12px">
            <div style="padding:12px;">
              <h3 style="margin:0 0 8px 0">Add a single game</h3>
              <p style="margin:0 0 8px;color:var(--muted)">Upload an HTML file or give a URL to an HTML page. You can save the file/URL to cookies so it appears in Downloaded games.</p>
              <div style="display:flex;flex-direction:column;gap:8px">
                <label style="font-size:13px">Name <input id="add-game-name" placeholder="Optional display name" style="width:100%;padding:8px;border-radius:6px"></label>
                <label style="font-size:13px">Description <input id="add-game-desc" placeholder="Optional description" style="width:100%;padding:8px;border-radius:6px"></label>
                <div>
                  <input id="add-game-file" type="file" accept="text/html" />
                </div>
                <label style="font-size:13px"><input id="add-game-save-cookie" type="checkbox"> Try to save file to cookies (falls back to localStorage)</label>
                <div style="display:flex;gap:8px;align-items:center">
                  <input id="add-game-url" placeholder="https://example.com/game.html" style="flex:1;padding:8px;border-radius:6px">
                  <label style="display:flex;align-items:center;gap:6px"><input id="add-game-save-url" type="checkbox"> Save URL</label>
                </div>
                <div style="display:flex;gap:8px;justify-content:flex-end">
                  <button id="add-game-cancel" class="open">Cancel</button>
                  <button id="add-game-submit" class="play">Add Game</button>
                </div>
              </div>
            </div>

            <div style="padding:12px;border-left:1px solid rgba(255,255,255,0.03)">
              <h3 style="margin:0 0 8px 0">Add a gamelist.json</h3>
              <p style="margin:0 0 8px;color:var(--muted)">Upload a gamelist.json file or provide a URL to a gamelist.json. When added it will populate the main list. Optionally save the URL to persist across visits.</p>
              <div style="display:flex;flex-direction:column;gap:8px">
                <div>
                  <input id="add-gamelist-file" type="file" accept="application/json">
                </div>
                <label style="font-size:13px"><input id="add-gamelist-save-cookie" type="checkbox"> Try to save gamelist to cookies (may fail for large files)</label>
                <div style="display:flex;gap:8px;align-items:center">
                  <input id="add-gamelist-url" placeholder="https://example.com/gamelist.json" style="flex:1;padding:8px;border-radius:6px">
                  <label style="display:flex;align-items:center;gap:6px"><input id="add-gamelist-save-url" type="checkbox"> Save URL</label>
                </div>
                <div style="display:flex;gap:8px;justify-content:flex-end">
                  <button id="add-gamelist-cancel" class="open">Cancel</button>
                  <button id="add-gamelist-submit" class="play">Add Gamelist</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <canvas id="mp-canvas" width="800" height="360" style="background:#02121a;border-radius:8px;width:100%;height:360px;display:block"></canvas>
      </div>
    </div>
  </div>

  <footer>Games loaded from <code>gamelist.json</code>. Click Play to open the game in a new window.</footer>

  <script>
    // Contract:
    // - Input: GET /gamelist.json (array of {id,name,description,content})
    // - Output: Rendered card elements with Play buttons opening a new window showing the game's HTML content
    // - Errors: graceful message if fetch fails or JSON is empty

    const listEl = document.getElementById('list');

    function createCard(game){
      const wrap = document.createElement('div');
      wrap.className = 'card';

      // normalize: if gamelist entry provides a url field, treat it as content pointer
      if(game && game.url && !game.content){ game.content = { url: game.url }; }

      const h = document.createElement('h3'); h.textContent = game.name; wrap.appendChild(h);
  const p = document.createElement('div'); p.className = 'desc'; p.textContent = game.description || '';
      // if a saved version exists in cookie/localStorage, load it and mark the card
      const saved = loadSavedGame(game.id);
      if(saved){
        // saved may be a string (e.g., 'URL:...') or a parsed entry object
        if(typeof saved === 'object'){
          // prefer saved.content or saved.url
          if(saved.content) game.content = saved.content;
          else if(saved.url) game.content = { url: saved.url };
          else game.content = saved;
          // if saved entry provides a name/description, prefer those for display
          if(saved.name) h.textContent = saved.name;
        }else{
          game.content = saved;
        }
        const badge = document.createElement('span'); badge.className = 'badge-saved'; badge.textContent = 'Saved offline';
        h.appendChild(badge);
      }
      wrap.appendChild(p);

  const controls = document.createElement('div'); controls.className = 'controls';
  const play = document.createElement('button'); play.className = 'play'; play.textContent = 'Play';
  play.addEventListener('click', ()=>openGameWindow(game));

  // overflow menu for secondary actions
  const menuWrap = document.createElement('div'); menuWrap.style.position='relative';
  const menuBtn = document.createElement('button'); menuBtn.className='menu-btn'; menuBtn.textContent='⋯';
  const menu = document.createElement('div'); menu.className='menu';
  const openNew = document.createElement('button'); openNew.textContent='Open / Save external';
  openNew.addEventListener('click', ()=>{
    // If this entry points at an external URL, offer to save the URL or simply open it.
    if(game && game.content && (typeof game.content === 'object' && game.content.url || (typeof game.content === 'string' && game.content.startsWith('URL:')))){
      const url = (typeof game.content === 'string') ? game.content.replace(/^URL:/,'') : game.content.url;
      // Ask whether to save the URL to downloaded games first.
      const save = confirm('This game is an external URL. Click OK to save the URL to Downloaded games, or Cancel to just open it.');
      if(save){
        try{ saveGameUrlEntry(game.id + '-saved', url, {name: game.name, desc: game.description}); alert('Saved URL to downloaded games.'); }catch(e){ alert('Failed to save URL: '+e.message); }
      }
      // Open in new tab/window
      try{ window.open(url, '_blank'); }catch(e){ alert('Failed to open URL: '+e.message); }
      menu.style.display='none';
      return;
    }
    // otherwise show the source view for inline content
    openGameWindow(game, true);
    menu.style.display='none';
  });
  const dl = document.createElement('button'); dl.textContent='Download'; dl.addEventListener('click', ()=>{ downloadGame(game); menu.style.display='none'; });
  // Show either a Save (cookie) button or a Delete (cookie) button depending on whether
  // the entry already exists in cookies. We treat as "saved in cookie" when a cookie
  // key exists for gs_game_<id> or gs_game_<id>_url (legacy URL cookie).
  function isSavedInCookie(id){
    try{ return getCookie(`gs_game_${id}`) !== null || getCookie(`gs_game_${id}_url`) !== null; }catch(e){ return false; }
  }

  function makeSaveButton(){
    const btn = document.createElement('button'); btn.textContent='Save (cookie)';
    btn.addEventListener('click', ()=>{
      // If this entry is a URL, save as a URL entry. Otherwise attempt to save HTML content to cookie/localStorage
      if(game && game.content && (typeof game.content === 'object' && game.content.url || (typeof game.content === 'string' && game.content.startsWith('URL:')))){
        const url = (typeof game.content === 'string') ? game.content.replace(/^URL:/,'') : game.content.url;
        // use the JSON-aware helper for URL entries as well so metadata is preserved when possible
        try{ saveGameToCookie({ id: game.id, url }); localStorage.setItem(`gs_game_meta_${game.id}`, JSON.stringify({name: game.name, desc: game.description})); alert('Saved URL to downloaded games.'); }catch(e){ saveGameUrlEntry(game.id, url, {name: game.name, desc: game.description}); alert('Saved URL (fallback)'); }
      }else{
        saveGameToCookie(Object.assign({}, game));
        try{ localStorage.setItem(`gs_game_meta_${game.id}`, JSON.stringify({name: game.name, desc: game.description})); }catch(e){}
        alert('Saved game (attempted cookie, falls back to localStorage).');
      }
      // swap to delete button in the UI
      menu.removeChild(btn);
      const del = makeDeleteButton(); menu.appendChild(del);
      // add saved badge if missing
      if(!h.querySelector('.badge-saved')){ const badge = document.createElement('span'); badge.className='badge-saved'; badge.textContent='Saved offline'; h.appendChild(badge); }
      menu.style.display='none';
    });
    return btn;
  }

  function makeDeleteButton(){
    const btn = document.createElement('button'); btn.textContent='Delete (cookie)';
    btn.addEventListener('click', ()=>{
      try{
        const key = `gs_game_${game.id}`;
        // remove cookie forms and localStorage entries
        try{ document.cookie = encodeURIComponent(key)+'=; max-age=0; path=/'; document.cookie = encodeURIComponent(key+'_url')+'=; max-age=0; path=/'; }catch(e){}
        try{ localStorage.removeItem(key); localStorage.removeItem(key+'_url'); localStorage.removeItem(`gs_game_meta_${game.id}`); }catch(e){}
        // remove saved badge if present
        const badge = h.querySelector('.badge-saved'); if(badge) badge.remove();
        // swap back to save button
        menu.removeChild(btn);
        const saveBtn = makeSaveButton(); menu.appendChild(saveBtn);
        alert('Deleted saved cookie/localStorage entry.');
      }catch(e){ console.error('delete cookie failed', e); alert('Failed to delete saved cookie: '+e.message); }
      menu.style.display='none';
    });
    return btn;
  }

  // choose which button to show initially
  const initialButton = isSavedInCookie(game.id) ? makeDeleteButton() : makeSaveButton();
  menu.appendChild(openNew); menu.appendChild(dl); menu.appendChild(initialButton);
  menuWrap.appendChild(menuBtn); menuWrap.appendChild(menu);
  menuBtn.addEventListener('click', ()=>{ menu.style.display = menu.style.display === 'block' ? 'none' : 'block'; });
  // (removed per-card document listener) menu closing is handled by a single global handler added below

  controls.appendChild(play); controls.appendChild(menuWrap);
      wrap.appendChild(controls);

      return wrap;
    }

    function openGameWindow(game, showSource=false){
      // open a new window and write the content. include a small header when showSource is true.
      // Use a features string that doesn't include 'noopener' or 'noreferrer' so
      // we can obtain a valid Window object and write into it. For security,
      // immediately null out opener to avoid giving the new window a reference
      // back to this page.
      const w = window.open('', '_blank', 'width=900,height=700');
  if(!w) {
        // Popup blocked — fall back to an in-page preview using an iframe.
        const preview = document.createElement('div');
        preview.className = 'card';
        preview.innerHTML = `<h3>${escapeHtml(game.name)} (Preview)</h3><div class="desc">${escapeHtml(game.description||'')}</div><iframe style="width:100%;height:420px;border:1px solid rgba(255,255,255,0.06)" srcdoc="${escapeAttribute(game.content)}"></iframe>`;
        // insert at top so user sees it
        listEl.insertBefore(preview, listEl.firstChild);
        alert('Popup blocked. A preview has been inserted into the page. Allow popups to open the game in a new window.');
        return;
      }
      try{ w.opener = null; } catch(e) { /* ignore if cross-origin restrictions apply */ }
      const doc = w.document;
      // inject username and game id as globals so games can read window.GAME_USERNAME and window.GAME_ID
      const username = getUsername();
      const injectedPrefixParts = [];
      injectedPrefixParts.push(`window.GAME_ID = ${JSON.stringify(game.id)};`);
      if(username) injectedPrefixParts.push(`window.GAME_USERNAME = ${JSON.stringify(username)};`);
  const injectedPrefix = injectedPrefixParts.length ? `<script>${injectedPrefixParts.join('')}<\/script>` : '';
      // If saved game is a URL (object or URL string), open the URL directly
      if(game && game.content && (typeof game.content === 'object' && game.content.url || (typeof game.content === 'string' && game.content.startsWith('URL:')))){
        try{
          const url = typeof game.content === 'string' ? game.content.replace(/^URL:/,'') : game.content.url;
          w.location.href = url;
        }catch(e){
          // fallback: navigate current window
          window.open(typeof game.content === 'string' ? game.content.replace(/^URL:/,'') : game.content.url, '_blank');
        }
        return;
      }
      if(showSource){
        // show a page with the source html and an iframe to run it
        const escaped = game.content.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        doc.open();
        doc.write(`<!doctype html><html><head><meta charset=\"utf-8\"><title>${escapeHtml(game.name)} — Source</title><style>body{font-family:system-ui,Arial;padding:18px;background:#071023;color:#cfeef0}pre{background:#01121b;padding:12px;border-radius:8px;overflow:auto;max-height:60vh}</style></head><body><h1>${escapeHtml(game.name)}</h1><p>${escapeHtml(game.description||'')}</p><h2>Source</h2><pre>${escaped}</pre><h2>Preview</h2><iframe style=\"width:100%;height:40vh;border:1px solid rgba(255,255,255,0.06)\" srcdoc=\"${escapeAttribute(injectedPrefix + game.content)}\"></iframe></body></html>`);
        doc.close();
        return;
      }

      doc.open();
      doc.write(injectedPrefix + (game.content || '<!doctype html><meta charset="utf-8"><body><p>No content provided.</p></body>'));
      doc.close();
    }

    // Render an array of gamelist entries into the main list element.
    // Accepts entries with either a `content` (HTML string) or a `url` (string) field.
    function renderGames(arr){
      try{
        if(!arr || !Array.isArray(arr) || arr.length===0){ listEl.innerHTML = '<div class="empty">No games available.</div>'; return; }
        listEl.innerHTML = '';
        for(let i=0;i<arr.length;i++){
          const g = Object.assign({}, arr[i]);
          // ensure gamelist entry respects mutual exclusivity: prefer `url` over `content` when both provided
          if(g.url && g.content){
            // if both set, prefer url (treat as external pointer) and drop inline content
            delete g.content;
          }
          if(!g.id) g.id = 'g-'+i;
          // normalize url -> content pointer (createCard also does this but keep consistent)
          if(g.url && !g.content) g.content = { url: g.url };
          const card = createCard(g);
          listEl.appendChild(card);
        }
      }catch(e){ console.error('renderGames failed', e); listEl.innerHTML = '<div class="empty">Failed to render games.</div>'; }
    }

    // Simple page navigation helper
    function switchPage(page){
      const pages = ['all','gamelists','downloaded','settings'];
      pages.forEach(p=>{ const el = document.getElementById('page-'+p); if(!el) return; el.style.display = (p===page)?'block':'none'; const btn = document.getElementById('nav-'+p); if(btn) btn.style.boxShadow = (p===page)?'inset 0 -2px 0 var(--accent)':''; });
      // page-specific actions
      if(page==='all'){
        // ensure list has current games (no-op if already rendered)
      }
      if(page==='gamelists'){
        const container = document.getElementById('gamelist-sources'); container.innerHTML = '';
        // built-in
        const built = document.createElement('div'); built.textContent = 'Built-in: gamelist.json'; const loadBuilt = document.createElement('button'); loadBuilt.className='open'; loadBuilt.textContent='Load'; loadBuilt.addEventListener('click', ()=>{ load(); switchPage('all'); }); built.appendChild(loadBuilt); container.appendChild(built);
        // local saved
        try{ const saved = localStorage.getItem('gs_gamelist'); if(saved){ const d=document.createElement('div'); d.textContent='Local saved gamelist'; const bt=document.createElement('button'); bt.className='open'; bt.textContent='Load'; bt.addEventListener('click', ()=>{ renderGames(JSON.parse(saved)); switchPage('all'); }); d.appendChild(bt); container.appendChild(d); } }catch(e){}
        // saved URL
        try{ const u = localStorage.getItem('gs_gamelist_url') || getCookie('gs_gamelist_url'); if(u){ const d=document.createElement('div'); d.textContent = 'Saved URL: '+u; const bt=document.createElement('button'); bt.className='open'; bt.textContent='Load'; bt.addEventListener('click', async ()=>{ try{ const r = await fetch(u); const arr = await r.json(); renderGames(arr); switchPage('all'); }catch(e){ alert('Failed to fetch saved gamelist URL: '+e.message); } }); d.appendChild(bt); container.appendChild(d); } }catch(e){}
      }
      if(page==='downloaded'){
        // render into downloaded-list
        const dl = document.getElementById('downloaded-list'); dl.innerHTML = '';
        const arr = listDownloadedGames();
        if(arr.length===0){ dl.innerHTML = '<div class="empty">No downloaded games saved.</div>'; return; }
        arr.forEach(item=>{ const name=(item.meta&&item.meta.name)||item.id; const desc=(item.meta&&item.meta.desc)||''; const game={id:item.id,name,description:desc}; if(typeof item.value==='string'&&item.value.startsWith('URL:')) game.content={url:item.value.replace(/^URL:/,'')}; else game.content=item.value||''; dl.appendChild(createCard(game)); });
      }
      if(page==='settings'){
        document.getElementById('settings-encrypted').checked = !!localStorage.getItem('gs_encrypted_active');
      }
    }

    // wire nav
    (function(){ ['all','gamelists','downloaded','settings'].forEach(p=>{ const b=document.getElementById('nav-'+p); if(!b) return; b.addEventListener('click', ()=> switchPage(p)); });
      // default to All Games
      switchPage('all');
      document.getElementById('settings-export').addEventListener('click', exportCookies);
      document.getElementById('settings-clear').addEventListener('click', ()=>{ if(confirm('Clear all saved localStorage and cookies for this app?')){ // clear keys prefixed with gs_
        try{ for(let i=localStorage.length-1;i>=0;i--){ const k=localStorage.key(i); if(k && k.startsWith('gs_')) localStorage.removeItem(k); } const raw=document.cookie.split('; ').filter(Boolean); raw.forEach(p=>{ const idx=p.indexOf('='); if(idx===-1) return; const k=decodeURIComponent(p.slice(0,idx)); if(k.startsWith('gs_')) document.cookie = k+'=; max-age=0; path=/'; }); alert('Cleared. Reloading page.'); location.reload(); }catch(e){ alert('Failed to clear: '+e.message); } } }); })();

    function escapeHtml(s){ return (s||'').replace(/[&<>\"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' })[c]); }
    function escapeAttribute(s){ return (s||'').replace(/&/g,'&amp;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // Trigger a download of the game's HTML content as a .html file
    function safeFilename(name){
      return (name||'game').toLowerCase().replace(/[^a-z0-9-_]+/g,'-').replace(/^-+|-+$/g,'') || 'game';
    }

    async function downloadGame(game){
      try{
        // If this is a URL entry, fetch it then download the response body as HTML
        let content = null;
        if(game && game.content && (typeof game.content === 'object' && game.content.url || (typeof game.content === 'string' && game.content.startsWith('URL:')))){
          const url = (typeof game.content === 'string') ? game.content.replace(/^URL:/,'') : game.content.url;
          const res = await fetch(url);
          if(!res.ok) throw new Error('Failed to fetch URL: HTTP '+res.status);
          const txt = await res.text();
          content = txt;
        }else{
          content = game.content || '<!doctype html><meta charset="utf-8"><body><p>No content provided.</p></body>';
        }
        const blob = new Blob([content], {type: 'text/html'});
        const objUrl = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = objUrl; a.download = safeFilename(game.name) + '.html'; document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(objUrl), 5000);
      }catch(e){ alert('Download failed: '+(e && e.message)); console.error(e); }
    }

    // --- username / cookie helpers ---
    function setCookie(name, value, days){
      let s = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
      if(days){
        const d = new Date(); d.setTime(d.getTime() + days*24*60*60*1000);
        s += `; expires=${d.toUTCString()}`;
      }
      s += '; path=/';
      document.cookie = s;
    }

    function getCookie(name){
      const re = new RegExp('(?:^|; )' + name.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') + '=([^;]*)');
      const m = document.cookie.match(re);
      return m ? decodeURIComponent(m[1]) : null;
    }

    function setUsername(name){
      try{
        // prefer cookie for portability; also keep a copy in localStorage
        setCookie('gs_username', name, 365);
        localStorage.setItem('gs_username', name);
      }catch(e){
        console.warn('Could not persist username to cookie/localStorage', e);
      }
      updateUsernameDisplay();
    }

    function getUsername(){
      return getCookie('gs_username') || localStorage.getItem('gs_username') || '';
    }

    function updateUsernameDisplay(){
      const el = document.getElementById('username-display');
      const name = getUsername();
      el.textContent = name ? `Hello, ${name}` : '';
    }

    // modal wiring
    (function(){
  const modal = document.getElementById('username-modal');
  const input = document.getElementById('username-input');
  const passInput = document.getElementById('username-password');
  const save = document.getElementById('save-username');
  const change = document.getElementById('change-username');

      change.addEventListener('click', ()=>{ input.value = getUsername() || ''; passInput.value = ''; modal.style.display = 'flex'; input.focus(); });
        save.addEventListener('click', async ()=>{ const v = (input.value||'').trim(); if(!v){ alert('Please enter a name.'); return; }
          // optional password: read from modal field (empty = no encryption)
          const pass = (passInput.value||'').trim();
          try{
            if(pass){
              // derive key and lock store
              await promptPasswordAndLock(pass);
            }
          }catch(e){ console.error('lock failed', e); alert('Failed to enable encryption: '+e.message); }
          setUsername(v); passInput.value=''; modal.style.display='none'; });

      // show on first load if no username
      if(!getUsername()){
        modal.style.display = 'flex';
        input.focus();
      } else {
        updateUsernameDisplay();
      }
    })();

    // Save a full game entry (JSON) to cookie if small enough, otherwise fall back to localStorage.
    // We store the entire entry as JSON so metadata (name/description/content/url) is preserved.
    function saveGameToCookie(game){
      const key = `gs_game_${game.id}`;
      // ensure we store a JSON string
      const entry = (typeof game === 'string') ? { id: game } : Object.assign({}, game);
      const payload = JSON.stringify(entry);
      // rough safe cookie size limit (per-cookie) — browsers vary; use 4000 bytes as safe cap
      const encoder = new TextEncoder();
      const bytes = encoder.encode(payload).length;
      if(bytes <= 4000){
        try{
          setCookie(key, payload, 365);
          alert(`Saved entry to cookie as ${key} (${bytes} bytes)`);
          return;
        }catch(e){
          console.warn('cookie set failed', e);
        }
      }
      // fallback to localStorage (store the JSON string)
      try{
        localStorage.setItem(key, payload);
        alert(`Saved entry to localStorage as ${key} (${bytes} bytes). Cookie was too small or blocked.`);
      }catch(e){
        alert('Failed to save game entry: storage unavailable or payload too large.');
        console.error(e);
      }
    }

    // load saved game entry (from cookie or localStorage)
    // returns either a parsed object (the original entry) or a raw string (e.g., 'URL:...')
    function loadSavedGame(id){
      const key = `gs_game_${id}`;
      const raw = getCookie(key) || localStorage.getItem(key) || null;
      if(!raw) return null;
      if(typeof raw === 'string'){
        const t = raw.trim();
        if((t.startsWith('{') || t.startsWith('['))){
          try{ return JSON.parse(raw); }catch(e){ /* not JSON, fall through */ }
        }
      }
      return raw;
    }

    // --- Web Crypto helpers for optional password encryption ---
    // Uses PBKDF2 to derive an AES-GCM key from a password. Stores encrypted store under 'gs_store_encrypted'.
    async function deriveKeyFromPassword(password, saltHex){
      const enc = new TextEncoder();
      const salt = saltHex ? hexToBuf(saltHex) : crypto.getRandomValues(new Uint8Array(16));
      const pwKey = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveKey']);
      const key = await crypto.subtle.deriveKey({name:'PBKDF2', salt, iterations: 200000, hash: 'SHA-256'}, pwKey, {name:'AES-GCM', length: 256}, false, ['encrypt','decrypt']);
      return {key, salt};
    }

    function bufToHex(buf){ return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
    function hexToBuf(hex){ const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b=>parseInt(b,16))); return bytes; }

    async function encryptWithKey(keyObj, dataStr){
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const enc = new TextEncoder();
      const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, keyObj, enc.encode(dataStr));
      return { iv: bufToHex(iv), ct: bufToHex(ct) };
    }

    async function decryptWithKey(keyObj, ivHex, ctHex){
      const iv = hexToBuf(ivHex);
      const ct = hexToBuf(ctHex);
      const dec = await crypto.subtle.decrypt({name:'AES-GCM', iv}, keyObj, ct);
      return new TextDecoder().decode(dec);
    }

    // Save all gs_game_* and gs_game_meta_* and gs_gamelist* entries into encrypted bundle and remove them from clear storage
    async function promptPasswordAndLock(password){
      const {key, salt} = await deriveKeyFromPassword(password);
      // store session key for runtime operations
      window.__GS_AES_KEY = key;
      // build a bundle
      const bundle = {};
      try{
        for(let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if(!k) continue;
          if(k.startsWith('gs_game_') || k.startsWith('gs_game_meta_') || k.startsWith('gs_gamelist') || k==='gs_gamelist_url'){
            bundle[k] = localStorage.getItem(k);
            localStorage.removeItem(k);
          }
        }
        // also gather cookies that start with gs_game_
        const raw = document.cookie.split('; ').filter(Boolean);
        for(const p of raw){ const idx = p.indexOf('='); if(idx===-1) continue; const k = decodeURIComponent(p.slice(0,idx)); const v = decodeURIComponent(p.slice(idx+1)||''); if(k.startsWith('gs_game_')){ bundle[k] = v; document.cookie = k+'=; max-age=0; path=/'; } }
      }catch(e){ console.error('bundle build', e); }
      const json = JSON.stringify(bundle);
      const enc = await encryptWithKey(key, json);
      const stored = { salt: bufToHex(salt), iv: enc.iv, ct: enc.ct };
      localStorage.setItem('gs_store_encrypted', JSON.stringify(stored));
      // generate certificate (key pair) and store encrypted private key
      await generateAndStoreCertificate(key);
      // mark that encrypted mode is active
      localStorage.setItem('gs_encrypted_active', '1');
      alert('Saved data encrypted for this password. You will be asked for the password to unlock on each visit.');
    }

    async function tryUnlockWithPassword(password){
      const encBlob = localStorage.getItem('gs_store_encrypted');
      if(!encBlob) return true; // nothing to unlock
      const stored = JSON.parse(encBlob);
      const {key} = await deriveKeyFromPassword(password, stored.salt);
      window.__GS_AES_KEY = key; // keep session key
      try{
        const json = await decryptWithKey(key, stored.iv, stored.ct);
        const bundle = JSON.parse(json);
        // restore into localStorage (in memory) but do not re-create cookies unless needed
        for(const k of Object.keys(bundle)){
          try{ localStorage.setItem(k, bundle[k]); }catch(e){ console.error('restore key',k,e); }
        }
        // load and decrypt private key if present
        await loadPrivateKeyIfEncrypted(key);
        return true;
      }catch(e){ console.error('unlock failed', e); return false; }
    }

    // --- certificate/keypair for signing chat messages ---
    async function generateAndStoreCertificate(aesKey){
      try{
        // generate ECDSA P-256 key pair
        const kp = await crypto.subtle.generateKey({name:'ECDSA', namedCurve:'P-256'}, true, ['sign','verify']);
        // export pubkey as JWK
        const pubJwk = await crypto.subtle.exportKey('jwk', kp.publicKey);
        // export private key as JWK (so we can re-import easily) and encrypt the JSON with AES key
        const privJwk = await crypto.subtle.exportKey('jwk', kp.privateKey);
        const privJson = JSON.stringify(privJwk);
        const enc = await encryptWithKey(aesKey, privJson);
        localStorage.setItem('gs_pubkey_jwk', JSON.stringify(pubJwk));
        localStorage.setItem('gs_priv_jwk_enc', JSON.stringify(enc));
        // import into session for immediate use
        const importedPriv = await crypto.subtle.importKey('jwk', privJwk, {name:'ECDSA', namedCurve:'P-256'}, false, ['sign']);
        window.__GS_PRIV_KEY_CRYPTO = importedPriv;
        window.__GS_PUB_JWK = pubJwk;
        return true;
      }catch(e){ console.error('generate cert failed', e); return false; }
    }

    async function loadPrivateKeyIfEncrypted(aesKey){
      const enc = localStorage.getItem('gs_priv_jwk_enc');
      if(!enc) return null;
      try{
        const obj = JSON.parse(enc);
        const jwkJson = await decryptWithKey(aesKey, obj.iv, obj.ct);
        const jwk = JSON.parse(jwkJson);
        const priv = await crypto.subtle.importKey('jwk', jwk, {name:'ECDSA', namedCurve:'P-256'}, false, ['sign']);
        window.__GS_PRIV_KEY_CRYPTO = priv;
        // also load public JWK if stored
        const pubj = localStorage.getItem('gs_pubkey_jwk'); if(pubj) try{ window.__GS_PUB_JWK = JSON.parse(pubj); }catch(e){}
        return priv;
      }catch(e){ console.error('load priv failed', e); }
      return null;
    }

    // Sign a message object (returns base64 signature). Uses stored private key if available (unlocked by password), otherwise returns null.
    async function signMessage(payload){
      try{
        // load private key (if stored encrypted, we need to decrypt with provided sessionKey stored in window.__GS_AES_KEY)
        if(window.__GS_PRIV_KEY_CRYPTO){
          const msg = new TextEncoder().encode(JSON.stringify(payload));
          const sig = await crypto.subtle.sign({name:'ECDSA', hash:'SHA-256'}, window.__GS_PRIV_KEY_CRYPTO, msg);
          return btoa(String.fromCharCode(...new Uint8Array(sig)));
        }
        // attempt to load encrypted private key using session AES key
        if(window.__GS_AES_KEY){
          await loadPrivateKeyIfEncrypted(window.__GS_AES_KEY);
          if(window.__GS_PRIV_KEY_CRYPTO){
            const msg = new TextEncoder().encode(JSON.stringify(payload));
            const sig = await crypto.subtle.sign({name:'ECDSA', hash:'SHA-256'}, window.__GS_PRIV_KEY_CRYPTO, msg);
            return btoa(String.fromCharCode(...new Uint8Array(sig)));
          }
        }
        return null;
      }catch(e){ console.error('sign failed', e); return null; }
    }

    // Send a message via ConnectionManager with signature and public key attached when possible
    async function sendSigned(msg){
      try{
        const payload = Object.assign({}, msg, { ts: msg.ts || Date.now() });
        const sig = await signMessage(payload);
        const out = Object.assign({}, payload);
        if(sig && window.__GS_PUB_JWK){ out.__sig = sig; out.__pub = window.__GS_PUB_JWK; }
        ConnectionManager.send(out);
        return true;
      }catch(e){ console.error('sendSigned', e); throw e; }
    }

    // Verify a signature using provided public JWK
    async function verifyMessageSignature(payload, signatureB64, pubJwk){
      try{
        const pub = await crypto.subtle.importKey('jwk', pubJwk, {name:'ECDSA', namedCurve:'P-256'}, false, ['verify']);
        const sig = Uint8Array.from(atob(signatureB64), c=>c.charCodeAt(0));
        const msg = new TextEncoder().encode(JSON.stringify(payload));
        const ok = await crypto.subtle.verify({name:'ECDSA', hash:'SHA-256'}, pub, sig, msg);
        return ok;
      }catch(e){ console.error('verify failed', e); return false; }
    }

    // --- WebRTC/manual-signaling connection manager (data channel) ---
    // Broadcast channel for game windows to communicate with the main page.
    // Messages should be objects with at least {gameId, type, ...}
    const gameBC = new BroadcastChannel('game-sync');

    const ConnectionManager = (function(){
      let pc = null; let dc = null; let isHost = false;

      async function createPeer(){
        pc = new RTCPeerConnection();
        pc.onicecandidate = e => {
          // ICE candidates will be included in the SDP we copy; nothing special here
        };
        pc.ondatachannel = ev => {
          dc = ev.channel;
          setupDataChannel(dc);
        };
        return pc;
      }

      function setupDataChannel(channel){
        channel.onopen = ()=>{ appendChatMessage('System', 'Data channel open'); };
        channel.onclose = ()=>{ appendChatMessage('System', 'Data channel closed'); };
        channel.onmessage = ev => {
          try{
              const msg = JSON.parse(ev.data);
              // verify signature if present
              let verified = false;
              (async ()=>{
                try{
                  if(msg && msg.__sig && msg.__pub){
                    const payload = { type: msg.type, name: msg.name, text: msg.text, ts: msg.ts };
                    verified = await verifyMessageSignature(payload, msg.__sig, msg.__pub);
                  }
                }catch(e){ console.error('verify error', e); }
                if(msg.type === 'chat') appendChatMessage(msg.name||'Peer', msg.text, verified);
                if(msg.type === 'score') updateRemoteScore(msg.value);
                if(msg.type === 'mp') handleMpMessage(msg.payload);
                // forward all messages coming from the network to game windows via BroadcastChannel
                try{ gameBC.postMessage(Object.assign({}, msg, {network:true, __verified: !!verified})); }catch(e){/* ignore */}
              })();
          }catch(e){ console.log('raw message', ev.data); }
        };
      }

      async function host(){
        isHost = true;
        await createPeer();
        dc = pc.createDataChannel('game');
        setupDataChannel(dc);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        // return full SDP to present to the other peer
        return JSON.stringify(pc.localDescription);
      }

      async function joinWithOffer(offerSdp){
        isHost = false;
        await createPeer();
        const offer = JSON.parse(offerSdp);
        await pc.setRemoteDescription(offer);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        return JSON.stringify(pc.localDescription);
      }

      async function acceptAnswer(answerSdp){
        const answer = JSON.parse(answerSdp);
        await pc.setRemoteDescription(answer);
      }

      function send(obj){ if(dc && dc.readyState === 'open') dc.send(JSON.stringify(obj)); }

      return { host, joinWithOffer, acceptAnswer, send };
    })();

    // UI wiring for connection buttons and signaling modal
    (function(){
      const hostBtn = document.getElementById('host-btn');
      const joinBtn = document.getElementById('join-btn');
      const bluetoothBtn = document.getElementById('bluetooth-btn');
      const signalModal = document.getElementById('signal-modal');
      const signalOut = document.getElementById('signal-out');
      const signalIn = document.getElementById('signal-in');
      const signalCopy = document.getElementById('signal-copy');
      const signalSendBt = document.createElement('button'); signalSendBt.className='open'; signalSendBt.textContent='Send via Bluetooth';
      signalCopy.parentNode.insertBefore(signalSendBt, signalCopy.nextSibling);
      const signalAccept = document.getElementById('signal-accept');
      const signalClose = document.getElementById('signal-close');

      // Bluetooth state
      let btDevice = null, btServer = null, btWriteChar = null, btNotifyChar = null;
      const NUS_SERVICE = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
      const NUS_TX = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // write
      const NUS_RX = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // notify

      async function startBluetoothSignaling(){
        if(!navigator.bluetooth){ alert('Web Bluetooth not supported in this browser.'); return; }
        try{
          btDevice = await navigator.bluetooth.requestDevice({filters:[], optionalServices:[NUS_SERVICE]});
          btServer = await btDevice.gatt.connect();
          const service = await btServer.getPrimaryService(NUS_SERVICE);
          try{ btWriteChar = await service.getCharacteristic(NUS_TX); }catch(e){ btWriteChar = null; }
          try{ btNotifyChar = await service.getCharacteristic(NUS_RX); }catch(e){ btNotifyChar = null; }
          if(btNotifyChar){
            await btNotifyChar.startNotifications();
            btNotifyChar.addEventListener('characteristicvaluechanged', e=>{
              const v = e.target.value; const decoder = new TextDecoder(); const txt = decoder.decode(v);
              // paste into signal-in for user to accept
              signalIn.value = txt;
              alert('Received signaling data via Bluetooth (pasted into Remote box). Click Accept to process.');
            });
          }
          alert('Bluetooth device connected for signaling. Use the Signal modal to copy/send text via Bluetooth.');
        }catch(err){ console.error(err); alert('Bluetooth connection failed: '+err.message); }
      }

      async function writeToBluetooth(text){
        if(!btWriteChar && !btNotifyChar){ alert('No writable Bluetooth characteristic available. Connect first.'); return; }
        try{
          const encoder = new TextEncoder();
          const data = encoder.encode(text);
          // some devices use TX for writes, others use the RX characteristic; try both
          if(btWriteChar){ await btWriteChar.writeValue(data); }
          else if(btNotifyChar){ await btNotifyChar.writeValueWithResponse ? await btNotifyChar.writeValueWithResponse(data) : await btNotifyChar.writeValue(data); }
          alert('Sent via Bluetooth');
        }catch(err){ console.error(err); alert('Bluetooth write failed: '+err.message); }
      }

      signalSendBt.addEventListener('click', ()=>{ if(!btDevice) startBluetoothSignaling().then(()=>writeToBluetooth(signalOut.value)).catch(e=>console.error(e)); else writeToBluetooth(signalOut.value); });

      hostBtn.addEventListener('click', async ()=>{
        signalModal.style.display='flex';
        try{
          const s = await ConnectionManager.host();
          signalOut.value = s;
        }catch(e){ alert('Failed to create host: '+e.message); }
      });

      joinBtn.addEventListener('click', ()=>{ signalModal.style.display='flex'; signalOut.value='Paste answer after accepting remote offer into the right box and click Accept.'; });

  bluetoothBtn.addEventListener('click', ()=>{ startBluetoothSignaling(); });

      signalCopy.addEventListener('click', ()=>{ signalOut.select(); document.execCommand('copy'); alert('Copied'); });
      signalClose.addEventListener('click', ()=>{ signalModal.style.display='none'; });
      signalAccept.addEventListener('click', async ()=>{
        const left = signalOut.value.trim();
        const right = signalIn.value.trim();
        try{
          // if we are the joiner and left is offer, we should generate answer
          if(left && !right){
            const answer = await ConnectionManager.joinWithOffer(left);
            signalOut.value = answer;
            alert('Created answer: copy and send to host');
            return;
          }
          if(right && left){
            // host accepts answer
            await ConnectionManager.acceptAnswer(right);
            alert('Connection attempted — check chat for status');
            return;
          }
          alert('Provide an offer in the left box (host) or paste remote offer and click Accept to create an answer.');
        }catch(e){ alert('Signaling error: '+e.message); }
      });
      // expose a manual entry point for other UI (bluetooth button)
      window.startBluetoothSignaling = startBluetoothSignaling;
    })();

    // Forward BroadcastChannel messages from game windows to the network (if not already network-forwarded)
    gameBC.onmessage = (ev)=>{
      const msg = ev.data;
      try{
        if(msg && msg.network) return; // already from network, don't echo
        // only forward if a data channel is available; sign messages when possible
        try{ sendSigned(msg); }catch(e){ /* if no connection, ignore or optionally queue */ }
      }catch(e){ console.error('gameBC onmessage', e); }
    };

    // Global handler: close any open card menus when clicking outside of a menu or its button.
    // This centralizes the logic and avoids per-card listeners which were interfering with collapse behavior.
    document.addEventListener('click', (e)=>{
      // if click inside a menu or on a menu button, don't close
      if(e.target.closest && (e.target.closest('.menu') || e.target.closest('.menu-btn'))) return;
      const openMenus = document.querySelectorAll('.menu');
      openMenus.forEach(m=>{ if(m.style.display === 'block') m.style.display = 'none'; });
    });

    // Chat handling
    function appendChatMessage(name, text){
      const box = document.getElementById('chat-messages');
      const el = document.createElement('div');
      el.style.marginBottom='8px';
      const verified = arguments.length>2 ? arguments[2] : false;
      el.innerHTML = `<strong style="display:block">${escapeHtml(name)}${verified ? ' <span style="color:#7fffd4;font-size:12px">(verified)</span>':''}</strong><div>${escapeHtml(text)}</div>`;
      box.appendChild(el); box.scrollTop = box.scrollHeight;
    }

    (function(){
      const openChat = document.getElementById('open-chat');
      const chatModal = document.getElementById('chat-modal');
      const closeChat = document.getElementById('close-chat');
      const chatSend = document.getElementById('chat-send');
      const chatInput = document.getElementById('chat-input');

      openChat.addEventListener('click', ()=>{ chatModal.style.display='block'; });
      closeChat.addEventListener('click', ()=>{ chatModal.style.display='none'; });
      chatSend.addEventListener('click', async ()=>{ const t = chatInput.value.trim(); if(!t) return; const payload = {type:'chat', name:getUsername(), text:t, ts: Date.now()};
        appendChatMessage(getUsername()||'Me', t, !!window.__GS_PRIV_KEY_CRYPTO);
        try{ await sendSigned(payload); }catch(e){ console.error('sendSigned failed', e); ConnectionManager.send(payload); }
        chatInput.value=''; });
    })();

    // Sample multiplayer canvas wiring
    (function(){
      const openSample = document.getElementById('open-sample');
      const sampleModal = document.getElementById('sample-modal');
      const closeSample = document.getElementById('close-sample');
      const canvas = document.getElementById('mp-canvas');
      const ctx = canvas.getContext('2d');
      let running = false;
      let local = {x:100,y:180,color:'#5eead4'};
      let remote = {x:700,y:180,color:'#ffb86b'};

      function render(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // draw local
        ctx.fillStyle = local.color; ctx.beginPath(); ctx.arc(local.x, local.y, 18, 0, Math.PI*2); ctx.fill();
        // draw remote
        ctx.fillStyle = remote.color; ctx.beginPath(); ctx.arc(remote.x, remote.y, 18, 0, Math.PI*2); ctx.fill();
      }

      function sendLocalPos(){ ConnectionManager.send({type:'mp', payload: {x: local.x, y: local.y}}); }

      function handleMpMessage(payload){ if(payload && typeof payload.x === 'number'){ remote.x = payload.x; remote.y = payload.y; } }
      window.handleMpMessage = handleMpMessage;

      function start(){ if(running) return; running=true; canvas.addEventListener('mousemove', onMove); window.requestAnimationFrame(tick); }
      function stop(){ if(!running) return; running=false; canvas.removeEventListener('mousemove', onMove); }
      function onMove(e){ const rect = canvas.getBoundingClientRect(); local.x = Math.max(18, Math.min(canvas.width-18, (e.clientX-rect.left)*(canvas.width/rect.width))); local.y = Math.max(18, Math.min(canvas.height-18, (e.clientY-rect.top)*(canvas.height/rect.height))); sendLocalPos(); }
      function tick(){ render(); if(running) requestAnimationFrame(tick); }

      openSample.addEventListener('click', ()=>{ sampleModal.style.display='flex'; start(); });
      closeSample.addEventListener('click', ()=>{ sampleModal.style.display='none'; stop(); });
    })();

    // --- helpers for storing/loading games and gamelist ---
    function saveGameUrlEntry(id, url, meta){
      const key = `gs_game_${id}`;
      try{
        localStorage.setItem(key, 'URL:'+url);
        if(meta) localStorage.setItem(`gs_game_meta_${id}`, JSON.stringify(meta));
        try{ setCookie(key+'_url', url, 365); }catch(e){}
        return true;
      }catch(e){ console.error('saveGameUrlEntry',e); return false; }
    }

    function saveGameContentEntry(id, content, meta){
      const key = `gs_game_${id}`;
      // build a full entry object that preserves meta
      const entry = { id, content };
      if(meta){ entry.name = meta.name || entry.name; entry.description = meta.desc || meta.description || entry.description; }
      try{
        // use the JSON-saving helper which will try cookies then localStorage
        saveGameToCookie(entry);
        // also keep a separate meta object for quick access if provided
        if(meta) try{ localStorage.setItem(`gs_game_meta_${id}`, JSON.stringify(meta)); }catch(e){}
      }catch(e){
        try{ localStorage.setItem(key, content); if(meta) localStorage.setItem(`gs_game_meta_${id}`, JSON.stringify(meta)); }catch(er){ console.error('save fallback',er); }
      }
    }

    function listDownloadedGames(){
      const found = {};
      try{
        for(let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if(!k) continue;
          if(k.startsWith('gs_game_meta_')) continue;
          if(k.startsWith('gs_game_')){
            const id = k.replace(/^gs_game_/,'');
            let raw = localStorage.getItem(k);
            // try parse JSON entries that were stored as full objects
            try{ if(typeof raw === 'string'){ const t = raw.trim(); if(t.startsWith('{')||t.startsWith('[')) raw = JSON.parse(raw); } }catch(e){}
            found[id] = {id, raw: raw};
            const m = localStorage.getItem(`gs_game_meta_${id}`);
            if(m) try{ found[id].meta = JSON.parse(m); }catch(e){}
          }
        }
      }catch(e){ console.error(e); }
      try{
        const raw = document.cookie.split('; ').filter(Boolean);
        raw.forEach(p=>{
          const idx = p.indexOf('='); if(idx===-1) return; const key = decodeURIComponent(p.slice(0,idx)); const val = decodeURIComponent(p.slice(idx+1)||'');
          if(key.startsWith('gs_game_')){
            const id = key.replace(/^gs_game_/,'');
            let parsed = val;
            try{ const t = (val||'').trim(); if(t.startsWith('{')||t.startsWith('[')) parsed = JSON.parse(val); }catch(e){}
            if(!found[id]) found[id] = {id, raw: parsed};
          }
        });
      }catch(e){ }
      return Object.keys(found).map(id=>{
        const entry = found[id];
        const metaKey = `gs_game_meta_${id}`;
        let meta = null;
        try{ meta = localStorage.getItem(metaKey); if(meta) meta = JSON.parse(meta); }catch(e){}
        return { id, value: entry.raw, meta };
      });
    }

    function showDownloadedView(){
      const arr = listDownloadedGames();
      listEl.innerHTML = '';
      if(arr.length===0){ listEl.innerHTML = '<div class="empty">No downloaded games saved.</div>'; return; }
      arr.forEach(item=>{
        // item.value may be a parsed object (entry) or a string like 'URL:...'
        let name = (item.meta && item.meta.name) || item.id;
        let desc = (item.meta && item.meta.desc) || '';
        let content = '';
        if(item.value && typeof item.value === 'object'){
          // full entry stored as JSON
          if(item.value.name) name = item.value.name;
          if(item.value.description) desc = item.value.description;
          if(item.value.content) content = item.value.content;
          else if(item.value.url) content = { url: item.value.url };
        }else if(typeof item.value === 'string' && item.value.startsWith('URL:')){
          content = { url: item.value.replace(/^URL:/,'') };
        }else{
          content = item.value || '';
        }
        const game = { id: item.id, name, description: desc, content };
        const card = createCard(game);
        listEl.appendChild(card);
      });
    }

    function showAddModal(){ document.getElementById('add-modal').style.display = 'flex'; }
    function hideAddModal(){ document.getElementById('add-modal').style.display = 'none'; }

    // Wire up add-modal buttons and quick actions
    (function(){
  const addBtn = document.getElementById('add-game-btn');
  addBtn.addEventListener('click', ()=>{ showAddModal(); });

      const cancelGame = document.getElementById('add-game-cancel');
      const submitGame = document.getElementById('add-game-submit');
      const fileInput = document.getElementById('add-game-file');
      const urlInput = document.getElementById('add-game-url');
      const saveUrlCb = document.getElementById('add-game-save-url');

      cancelGame.addEventListener('click', ()=> hideAddModal());

      submitGame.addEventListener('click', async ()=>{
        const name = document.getElementById('add-game-name').value.trim();
        const desc = document.getElementById('add-game-desc').value.trim();
        if(fileInput.files && fileInput.files[0]){
          const f = fileInput.files[0];
          const txt = await f.text();
          const id = (f.name||('local-'+Date.now())).replace(/[^a-z0-9-_\.]/ig,'-');
          // If user opted to try to save to cookies, attempt cookies first (may fall back to localStorage)
          const tryCookie = document.getElementById('add-game-save-cookie') && document.getElementById('add-game-save-cookie').checked;
          if(tryCookie){
            const key = `gs_game_${id}`;
            try{
              setCookie(key, txt, 365);
              try{ localStorage.setItem(`gs_game_meta_${id}`, JSON.stringify({name: name||f.name, desc})); }catch(e){}
              alert(`Saved to cookie as ${key}`);
            }catch(e){
              // fallback to content storage
              saveGameContentEntry(id, txt, {name: name||f.name, desc});
            }
          }else{
            saveGameContentEntry(id, txt, {name: name||f.name, desc});
          }
          const game = {id, name: name||f.name, description: desc, content: txt};
          const card = createCard(game); listEl.insertBefore(card, listEl.firstChild);
          alert('Game added to downloaded games.'); hideAddModal(); return;
        }
        const u = urlInput.value.trim();
        if(u){
          const id = 'url-'+(Date.now());
          if(saveUrlCb.checked){ saveGameUrlEntry(id, u, {name, desc}); }
          try{
            const res = await fetch(u, {cache:'no-store'});
            const txt = await res.text();
            const game = { id, name: name||u, description: desc, content: saveUrlCb.checked ? {url: u} : txt };
            if(!saveUrlCb.checked) saveGameContentEntry(id, txt, {name: name||u, desc});
            const card = createCard(game); listEl.insertBefore(card, listEl.firstChild);
            alert('Game added.'); hideAddModal();
            return;
          }catch(e){ alert('Failed to fetch URL: '+e.message); }
        }
        alert('Please supply a file or a URL.');
      });

      // gamelist side
      const cancelG = document.getElementById('add-gamelist-cancel');
      const submitG = document.getElementById('add-gamelist-submit');
      const fileG = document.getElementById('add-gamelist-file');
      const urlG = document.getElementById('add-gamelist-url');
      const saveGcb = document.getElementById('add-gamelist-save-url');

      cancelG.addEventListener('click', ()=> hideAddModal());
      submitG.addEventListener('click', async ()=>{
        if(fileG.files && fileG.files[0]){
          try{
            const txt = await fileG.files[0].text();
            const arr = JSON.parse(txt);
            renderGames(arr);
            // respect user's choice to try saving gamelist into cookies
            const tryCookie = document.getElementById('add-gamelist-save-cookie') && document.getElementById('add-gamelist-save-cookie').checked;
            try{
              if(tryCookie){
                // cookies may be too small; attempt and fall back
                setCookie('gs_gamelist', txt, 365);
                alert('Gamelist saved to cookie (if it fits).');
              }else{
                localStorage.setItem('gs_gamelist', txt);
                alert('Gamelist loaded from file and saved locally.');
              }
            }catch(e){
              try{ localStorage.setItem('gs_gamelist', txt); alert('Gamelist saved locally (cookie failed).'); }catch(er){}
            }
            hideAddModal(); return;
          }catch(e){ alert('Failed to read/parse file: '+e.message); return; }
        }
        const u = urlG.value.trim();
        if(u){
          try{
            const res = await fetch(u, {cache:'no-store'});
            if(!res.ok) throw new Error('HTTP '+res.status);
            const arr = await res.json();
            renderGames(arr);
            if(saveGcb.checked){ try{ localStorage.setItem('gs_gamelist_url', u); setCookie('gs_gamelist_url', u, 365); }catch(e){} }
            hideAddModal(); alert('Gamelist loaded from URL.'); return;
          }catch(e){ alert('Failed to fetch gamelist URL: '+e.message); }
        }
        alert('Please select a file or provide a URL.');
      });
    })();

    async function load(){
      try{
        const res = await fetch('gamelist.json', {cache: 'no-store'});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const arr = await res.json();
        renderGames(arr);
        return;
      }catch(err){
        console.warn('gamelist.json fetch failed:', err && err.message);
        // try saved gamelist JSON in localStorage
        try{
          const saved = localStorage.getItem('gs_gamelist');
          if(saved){ const arr = JSON.parse(saved); renderGames(arr); return; }
        }catch(e){ console.error('failed to parse saved gamelist', e); }
        // try saved gamelist URL
        try{
          const u = localStorage.getItem('gs_gamelist_url') || getCookie('gs_gamelist_url');
          if(u){ const r = await fetch(u, {cache:'no-store'}); if(r.ok){ const arr = await r.json(); renderGames(arr); return; } }
        }catch(e){ console.error('failed to load saved gamelist url', e); }

        // no fallback available — show message with option to add
        listEl.innerHTML = `<div class="empty">Failed to load games: ${escapeHtml(err.message||String(err))}<br><small>Make sure to run a static server (see README.md). Example: <code>python3 -m http.server 8000</code></small><br><br><button id="add-gamelist-quick" class="open">Add gamelist / Add game</button></div>`;
        const btn = document.getElementById('add-gamelist-quick'); if(btn) btn.addEventListener('click', showAddModal);
        console.error(err);
      }
    }

    // If encrypted store active, prompt for password to unlock before loading gamelist
    (async function(){
      if(localStorage.getItem('gs_encrypted_active')){
        const p = prompt('Encrypted store detected. Enter your password to unlock saved games and keys:');
        if(p){
          const ok = await tryUnlockWithPassword(p);
          if(!ok) alert('Failed to unlock with that password. Encrypted saved data will remain locked.');
        }else{
          console.warn('Encrypted store present but no password provided.');
        }
      }
      load();
    })();

    // Export/Import cookies (exclude saved games prefixed with gs_game_)
    function exportCookies(){
      const raw = document.cookie.split('; ').filter(Boolean);
      const obj = {};
      raw.forEach(p=>{ const idx = p.indexOf('='); const k = decodeURIComponent(p.slice(0,idx)); const v = decodeURIComponent(p.slice(idx+1)||''); if(!k.startsWith('gs_game_')) obj[k]=v; });
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='cookies.json'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),5000);
    }

    function importCookiesFromFile(file){
      const reader = new FileReader();
      reader.onload = ()=>{
        try{
          const obj = JSON.parse(reader.result);
          for(const k of Object.keys(obj||{})){
            // write cookie for each key (30 days)
            document.cookie = encodeURIComponent(k)+'='+encodeURIComponent(String(obj[k]))+'; path=/; max-age='+(30*24*60*60);
          }
          alert('Imported cookies. Reload the page to apply any saved games.');
        }catch(e){ alert('Failed to parse JSON: '+e.message); }
      };
      reader.readAsText(file);
    }

    document.getElementById('export-cookies').addEventListener('click', exportCookies);
    const importBtn = document.getElementById('import-cookies');
    const fileInput = document.getElementById('import-file');
    importBtn.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', (e)=>{ const f = e.target.files && e.target.files[0]; if(f) importCookiesFromFile(f); });

    // Sidebar toggle and gamelists dropdown wiring (moved controls)
    (function(){
      const sidebarToggle = document.getElementById('sidebar-toggle');
      if(sidebarToggle) sidebarToggle.addEventListener('click', ()=>{ document.body.classList.toggle('sidebar-collapsed'); });

      const gToggle = document.getElementById('gamelists-toggle');
      const gList = document.getElementById('gamelists-list');
      if(gToggle && gList) gToggle.addEventListener('click', ()=>{ 
        const open = gList.style.display !== 'block';
        gList.style.display = open ? 'block' : 'none';
        // also show the Gamelists page so users can interact with saved sources
        if(open) switchPage('gamelists');
      });

      const gAdd = document.getElementById('gamelists-add');
      if(gAdd) gAdd.addEventListener('click', ()=>{ showAddModal(); });

      const builtLoad = document.getElementById('gamelist-load-built');
      if(builtLoad) builtLoad.addEventListener('click', ()=>{ load(); switchPage('all'); });
    })();
  </script>
</body>
</html>
