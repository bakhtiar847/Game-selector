<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game Selector</title>
  <style>
    :root{--bg:#0f1720;--card:#0b1220;--accent:#5eead4;--muted:#94a3b8}
    body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,#071023 0%,var(--bg) 100%);color:#e6eef6;min-height:100vh;display:flex;flex-direction:column}
    header{padding:28px 32px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:16px}
    h1{margin:0;font-size:20px}
    main{padding:28px;display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:20px;align-items:start}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .card h3{margin:0 0 8px 0;font-size:18px}
    .desc{color:var(--muted);font-size:14px;margin-bottom:12px}
  .controls{display:flex;gap:8px;align-items:center}
  .badge-saved{background:#052b22;color:#9ff3d9;padding:4px 8px;border-radius:999px;font-size:12px;font-weight:600;margin-left:8px}
    button.play{background:var(--accent);color:#042;border:0;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
    button.open{background:transparent;color:var(--accent);border:1px solid rgba(94,234,212,0.12);padding:6px 10px;border-radius:8px;cursor:pointer}
    .empty{color:var(--muted);grid-column:1/-1;text-align:center;padding:40px}
    footer{margin-top:auto;padding:18px 28px;color:var(--muted);font-size:13px}
    @media (max-width:520px){main{padding:16px;grid-template-columns:1fr}header{padding:18px}}
  </style>
</head>
<body>
  <header>
    <svg width="36" height="36" viewBox="0 0 24 24" fill="none" aria-hidden><rect width="24" height="24" rx="6" fill="#052938"></rect><path d="M6 8h12v2H6zM6 12h12v2H6z" fill="#5eead4"/></svg>
    <h1>Game Selector</h1>
    <div id="userBox" style="margin-left:auto;display:flex;align-items:center;gap:8px">
      <span id="username-display" style="color:var(--muted);font-size:13px"></span>
      <button id="change-username" class="open" style="padding:6px 10px">Change</button>
    </div>
    <div id="multiplayerBox" style="margin-left:12px;display:flex;align-items:center;gap:8px">
      <button id="host-btn" class="open" title="Host (manual WebRTC)">Host</button>
      <button id="join-btn" class="open" title="Join (manual WebRTC)">Join</button>
      <button id="bluetooth-btn" class="open" title="Bluetooth (browser-to-browser Bluetooth is not available)">Bluetooth</button>
      <button id="open-chat" class="open">Chat</button>
      <button id="open-sample" class="play">Open Sample</button>
    </div>
  </header>

  <!-- Username modal -->
  <div id="username-modal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);backdrop-filter:blur(4px);align-items:center;justify-content:center;z-index:60">
    <div style="background:var(--card);padding:20px;border-radius:12px;max-width:420px;width:90%;box-shadow:0 10px 40px rgba(2,6,23,0.7)">
      <h2 style="margin:0 0 8px 0">Welcome</h2>
      <p style="margin:0 0 12px;color:var(--muted)">Enter a display name that will be passed to games and saved for offline use.</p>
      <div style="display:flex;gap:8px">
        <input id="username-input" placeholder="Your name" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit">
        <button id="save-username" class="play">Save</button>
      </div>
    </div>
  </div>

  <main id="list">
    <div class="empty">Loading games…</div>
  </main>

  <!-- Signaling modal for manual offer/answer exchange -->
  <div id="signal-modal" style="display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);align-items:center;justify-content:center;z-index:70">
    <div style="background:var(--card);padding:18px;border-radius:12px;max-width:760px;width:92%">
      <h3 style="margin:0 0 8px 0">Connection signaling (manual)</h3>
      <div style="display:flex;gap:8px">
        <textarea id="signal-out" rows="6" style="flex:1;padding:8px;background:#00121a;color:#cfeef0;border-radius:8px;border:1px solid rgba(255,255,255,0.03)"></textarea>
        <textarea id="signal-in" rows="6" placeholder="Paste remote answer/offer here" style="flex:1;padding:8px;background:#00121a;color:#cfeef0;border-radius:8px;border:1px solid rgba(255,255,255,0.03)"></textarea>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px;justify-content:flex-end">
        <button id="signal-copy" class="open">Copy Out</button>
        <button id="signal-accept" class="play">Accept Remote</button>
        <button id="signal-close" class="open">Close</button>
      </div>
    </div>
  </div>

  <!-- Chat modal -->
  <div id="chat-modal" style="display:none;position:fixed;right:18px;bottom:18px;width:320px;z-index:80">
    <div style="background:var(--card);border-radius:12px;overflow:hidden;box-shadow:0 10px 40px rgba(2,6,23,0.6)">
      <div style="padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:space-between">
        <strong style="font-size:14px">Chat</strong>
        <button id="close-chat" class="open">Close</button>
      </div>
      <div id="chat-messages" style="height:260px;overflow:auto;padding:10px;background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent)"></div>
      <div style="display:flex;padding:8px;gap:8px;border-top:1px solid rgba(255,255,255,0.03)">
        <input id="chat-input" placeholder="Message" style="flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit">
        <button id="chat-send" class="play">Send</button>
      </div>
    </div>
  </div>

  <!-- Sample multiplayer game modal -->
  <div id="sample-modal" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;z-index:85;background:rgba(2,6,23,0.6)">
    <div style="background:var(--card);padding:18px;border-radius:12px;max-width:720px;width:94%;box-shadow:0 12px 48px rgba(2,6,23,0.6);">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <h3 style="margin:0">Sample Multiplayer — Button Race</h3>
        <div>
          <button id="close-sample" class="open">Close</button>
        </div>
      </div>
      <div style="display:flex;gap:20px;align-items:center">
        <div style="flex:1;text-align:center">
          <h4>Your score</h4>
          <div id="local-score" style="font-size:48px">0</div>
          <button id="hit-btn" class="play" style="margin-top:10px">Hit</button>
        </div>
        <div style="flex:1;text-align:center">
          <h4>Opponent score</h4>
          <div id="remote-score" style="font-size:48px">0</div>
        </div>
      </div>
    </div>
  </div>

  <footer>Games loaded from <code>gamelist.json</code>. Click Play to open the game in a new window.</footer>

  <script>
    // Contract:
    // - Input: GET /gamelist.json (array of {id,name,description,content})
    // - Output: Rendered card elements with Play buttons opening a new window showing the game's HTML content
    // - Errors: graceful message if fetch fails or JSON is empty

    const listEl = document.getElementById('list');

    function createCard(game){
      const wrap = document.createElement('div');
      wrap.className = 'card';

      const h = document.createElement('h3'); h.textContent = game.name; wrap.appendChild(h);
      const p = document.createElement('div'); p.className = 'desc'; p.textContent = game.description || '';
      // if a saved version exists in cookie/localStorage, load it and mark the card
      const saved = loadSavedGame(game.id);
      if(saved){
        // replace content so Play uses the saved offline version
        game.content = saved;
        const badge = document.createElement('span'); badge.className = 'badge-saved'; badge.textContent = 'Saved offline';
        h.appendChild(badge);
      }
      wrap.appendChild(p);

  const controls = document.createElement('div'); controls.className = 'controls';
  const play = document.createElement('button'); play.className = 'play'; play.textContent = 'Play';
  play.addEventListener('click', ()=>openGameWindow(game));
  const openNew = document.createElement('button'); openNew.className='open'; openNew.textContent='Open source';
  openNew.addEventListener('click', ()=>openGameWindow(game, true));
  const dl = document.createElement('button'); dl.className='open'; dl.textContent='Download';
  dl.addEventListener('click', ()=>downloadGame(game));
  const saveCookieBtn = document.createElement('button'); saveCookieBtn.className='open'; saveCookieBtn.textContent='Save (cookie)';
  saveCookieBtn.addEventListener('click', ()=>saveGameToCookie(game));
  controls.appendChild(play); controls.appendChild(openNew); controls.appendChild(dl); controls.appendChild(saveCookieBtn);
      wrap.appendChild(controls);

      return wrap;
    }

    function openGameWindow(game, showSource=false){
      // open a new window and write the content. include a small header when showSource is true.
      // Use a features string that doesn't include 'noopener' or 'noreferrer' so
      // we can obtain a valid Window object and write into it. For security,
      // immediately null out opener to avoid giving the new window a reference
      // back to this page.
      const w = window.open('', '_blank', 'width=900,height=700');
  if(!w) {
        // Popup blocked — fall back to an in-page preview using an iframe.
        const preview = document.createElement('div');
        preview.className = 'card';
        preview.innerHTML = `<h3>${escapeHtml(game.name)} (Preview)</h3><div class="desc">${escapeHtml(game.description||'')}</div><iframe style="width:100%;height:420px;border:1px solid rgba(255,255,255,0.06)" srcdoc="${escapeAttribute(game.content)}"></iframe>`;
        // insert at top so user sees it
        listEl.insertBefore(preview, listEl.firstChild);
        alert('Popup blocked. A preview has been inserted into the page. Allow popups to open the game in a new window.');
        return;
      }
      try{ w.opener = null; } catch(e) { /* ignore if cross-origin restrictions apply */ }
      const doc = w.document;
      // inject username as a global variable into the game's document so games can read window.GAME_USERNAME
      const username = getUsername();
      const injectedPrefix = username ? `<script>window.GAME_USERNAME = ${JSON.stringify(username)};<\/script>` : '';
      if(showSource){
        // show a page with the source html and an iframe to run it
        const escaped = game.content.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        doc.open();
        doc.write(`<!doctype html><html><head><meta charset=\"utf-8\"><title>${escapeHtml(game.name)} — Source</title><style>body{font-family:system-ui,Arial;padding:18px;background:#071023;color:#cfeef0}pre{background:#01121b;padding:12px;border-radius:8px;overflow:auto;max-height:60vh}</style></head><body><h1>${escapeHtml(game.name)}</h1><p>${escapeHtml(game.description||'')}</p><h2>Source</h2><pre>${escaped}</pre><h2>Preview</h2><iframe style=\"width:100%;height:40vh;border:1px solid rgba(255,255,255,0.06)\" srcdoc=\"${escapeAttribute(injectedPrefix + game.content)}\"></iframe></body></html>`);
        doc.close();
        return;
      }

      doc.open();
      doc.write(injectedPrefix + (game.content || '<!doctype html><meta charset="utf-8"><body><p>No content provided.</p></body>'));
      doc.close();
    }

    function escapeHtml(s){ return (s||'').replace(/[&<>\"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' })[c]); }
    function escapeAttribute(s){ return (s||'').replace(/&/g,'&amp;').replace(/\"/g,'&quot;').replace(/'/g,'&#39;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // Trigger a download of the game's HTML content as a .html file
    function safeFilename(name){
      return (name||'game').toLowerCase().replace(/[^a-z0-9-_]+/g,'-').replace(/^-+|-+$/g,'') || 'game';
    }

    function downloadGame(game){
      const blob = new Blob([game.content || '<!doctype html><meta charset="utf-8"><body><p>No content provided.</p></body>'], {type: 'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = safeFilename(game.name) + '.html';
      document.body.appendChild(a);
      a.click();
      a.remove();
      // release the object URL after a short timeout
      setTimeout(()=>URL.revokeObjectURL(url), 5000);
    }

    // --- username / cookie helpers ---
    function setCookie(name, value, days){
      let s = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
      if(days){
        const d = new Date(); d.setTime(d.getTime() + days*24*60*60*1000);
        s += `; expires=${d.toUTCString()}`;
      }
      s += '; path=/';
      document.cookie = s;
    }

    function getCookie(name){
      const re = new RegExp('(?:^|; )' + name.replace(/[.*+?^${}()|[\]\\]/g,'\\$&') + '=([^;]*)');
      const m = document.cookie.match(re);
      return m ? decodeURIComponent(m[1]) : null;
    }

    function setUsername(name){
      try{
        // prefer cookie for portability; also keep a copy in localStorage
        setCookie('gs_username', name, 365);
        localStorage.setItem('gs_username', name);
      }catch(e){
        console.warn('Could not persist username to cookie/localStorage', e);
      }
      updateUsernameDisplay();
    }

    function getUsername(){
      return getCookie('gs_username') || localStorage.getItem('gs_username') || '';
    }

    function updateUsernameDisplay(){
      const el = document.getElementById('username-display');
      const name = getUsername();
      el.textContent = name ? `Hello, ${name}` : '';
    }

    // modal wiring
    (function(){
      const modal = document.getElementById('username-modal');
      const input = document.getElementById('username-input');
      const save = document.getElementById('save-username');
      const change = document.getElementById('change-username');

      change.addEventListener('click', ()=>{ input.value = getUsername() || ''; modal.style.display = 'flex'; input.focus(); });
      save.addEventListener('click', ()=>{ const v = (input.value||'').trim(); if(v){ setUsername(v); modal.style.display='none'; } else { alert('Please enter a name.'); } });

      // show on first load if no username
      if(!getUsername()){
        modal.style.display = 'flex';
        input.focus();
      } else {
        updateUsernameDisplay();
      }
    })();

    // Save game HTML to cookie if small enough, otherwise fall back to localStorage.
    function saveGameToCookie(game){
      const key = `gs_game_${game.id}`;
      const payload = game.content || '';
      // rough safe cookie size limit (per-cookie) — browsers vary; use 4000 bytes as safe cap
      const encoder = new TextEncoder();
      const bytes = encoder.encode(payload).length;
      if(bytes <= 4000){
        try{
          setCookie(key, payload, 365);
          alert(`Saved to cookie as ${key} (${bytes} bytes)`);
          return;
        }catch(e){
          console.warn('cookie set failed', e);
        }
      }
      // fallback to localStorage
      try{
        localStorage.setItem(key, payload);
        alert(`Saved to localStorage as ${key} (${bytes} bytes). Cookie was too small.`);
      }catch(e){
        alert('Failed to save game: storage unavailable or payload too large.');
        console.error(e);
      }
    }

    // load saved game (from cookie or localStorage)
    function loadSavedGame(id){
      const key = `gs_game_${id}`;
      return getCookie(key) || localStorage.getItem(key) || null;
    }

    // --- WebRTC/manual-signaling connection manager (data channel) ---
    const ConnectionManager = (function(){
      let pc = null; let dc = null; let isHost = false;

      async function createPeer(){
        pc = new RTCPeerConnection();
        pc.onicecandidate = e => {
          // ICE candidates will be included in the SDP we copy; nothing special here
        };
        pc.ondatachannel = ev => {
          dc = ev.channel;
          setupDataChannel(dc);
        };
        return pc;
      }

      function setupDataChannel(channel){
        channel.onopen = ()=>{ appendChatMessage('System', 'Data channel open'); };
        channel.onclose = ()=>{ appendChatMessage('System', 'Data channel closed'); };
        channel.onmessage = ev => {
          try{
            const msg = JSON.parse(ev.data);
            if(msg.type === 'chat') appendChatMessage(msg.name||'Peer', msg.text);
            if(msg.type === 'score') updateRemoteScore(msg.value);
          }catch(e){ console.log('raw message', ev.data); }
        };
      }

      async function host(){
        isHost = true;
        await createPeer();
        dc = pc.createDataChannel('game');
        setupDataChannel(dc);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        // return full SDP to present to the other peer
        return JSON.stringify(pc.localDescription);
      }

      async function joinWithOffer(offerSdp){
        isHost = false;
        await createPeer();
        const offer = JSON.parse(offerSdp);
        await pc.setRemoteDescription(offer);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        return JSON.stringify(pc.localDescription);
      }

      async function acceptAnswer(answerSdp){
        const answer = JSON.parse(answerSdp);
        await pc.setRemoteDescription(answer);
      }

      function send(obj){ if(dc && dc.readyState === 'open') dc.send(JSON.stringify(obj)); }

      return { host, joinWithOffer, acceptAnswer, send };
    })();

    // UI wiring for connection buttons and signaling modal
    (function(){
      const hostBtn = document.getElementById('host-btn');
      const joinBtn = document.getElementById('join-btn');
      const bluetoothBtn = document.getElementById('bluetooth-btn');
      const signalModal = document.getElementById('signal-modal');
      const signalOut = document.getElementById('signal-out');
      const signalIn = document.getElementById('signal-in');
      const signalCopy = document.getElementById('signal-copy');
      const signalAccept = document.getElementById('signal-accept');
      const signalClose = document.getElementById('signal-close');

      hostBtn.addEventListener('click', async ()=>{
        signalModal.style.display='flex';
        try{
          const s = await ConnectionManager.host();
          signalOut.value = s;
        }catch(e){ alert('Failed to create host: '+e.message); }
      });

      joinBtn.addEventListener('click', ()=>{ signalModal.style.display='flex'; signalOut.value='Paste answer after accepting remote offer into the right box and click Accept.'; });

      bluetoothBtn.addEventListener('click', ()=>{ alert('Direct browser-to-browser Bluetooth hosting is not supported. Use Host/Join manual signaling or a central server.'); });

      signalCopy.addEventListener('click', ()=>{ signalOut.select(); document.execCommand('copy'); alert('Copied'); });
      signalClose.addEventListener('click', ()=>{ signalModal.style.display='none'; });
      signalAccept.addEventListener('click', async ()=>{
        const left = signalOut.value.trim();
        const right = signalIn.value.trim();
        try{
          // if we are the joiner and left is offer, we should generate answer
          if(left && !right){
            const answer = await ConnectionManager.joinWithOffer(left);
            signalOut.value = answer;
            alert('Created answer: copy and send to host');
            return;
          }
          if(right && left){
            // host accepts answer
            await ConnectionManager.acceptAnswer(right);
            alert('Connection attempted — check chat for status');
            return;
          }
          alert('Provide an offer in the left box (host) or paste remote offer and click Accept to create an answer.');
        }catch(e){ alert('Signaling error: '+e.message); }
      });
    })();

    // Chat handling
    function appendChatMessage(name, text){
      const box = document.getElementById('chat-messages');
      const el = document.createElement('div');
      el.style.marginBottom='8px';
      el.innerHTML = `<strong style="display:block">${escapeHtml(name)}</strong><div>${escapeHtml(text)}</div>`;
      box.appendChild(el); box.scrollTop = box.scrollHeight;
    }

    (function(){
      const openChat = document.getElementById('open-chat');
      const chatModal = document.getElementById('chat-modal');
      const closeChat = document.getElementById('close-chat');
      const chatSend = document.getElementById('chat-send');
      const chatInput = document.getElementById('chat-input');

      openChat.addEventListener('click', ()=>{ chatModal.style.display='block'; });
      closeChat.addEventListener('click', ()=>{ chatModal.style.display='none'; });
      chatSend.addEventListener('click', ()=>{ const t = chatInput.value.trim(); if(!t) return; appendChatMessage(getUsername()||'Me', t); ConnectionManager.send({type:'chat', name:getUsername(), text:t}); chatInput.value=''; });
    })();

    // Sample game wiring
    (function(){
      const openSample = document.getElementById('open-sample');
      const sampleModal = document.getElementById('sample-modal');
      const closeSample = document.getElementById('close-sample');
      const hitBtn = document.getElementById('hit-btn');
      const localScoreEl = document.getElementById('local-score');
      const remoteScoreEl = document.getElementById('remote-score');
      let localScore = 0; let remoteScore = 0;

      function updateRemoteScore(v){ remoteScore = v; remoteScoreEl.textContent = remoteScore; }
      window.updateRemoteScore = updateRemoteScore; // expose for datachannel handler

      openSample.addEventListener('click', ()=>{ sampleModal.style.display='flex'; });
      closeSample.addEventListener('click', ()=>{ sampleModal.style.display='none'; });
      hitBtn.addEventListener('click', ()=>{ localScore++; localScoreEl.textContent = localScore; ConnectionManager.send({type:'score', value: localScore}); });
    })();

    async function load(){
      try{
        const res = await fetch('gamelist.json', {cache: 'no-store'});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const arr = await res.json();
        listEl.innerHTML = '';
        if(!Array.isArray(arr) || arr.length===0){
          listEl.innerHTML = '<div class="empty">No games found in <code>gamelist.json</code>.</div>';
          return;
        }
        arr.forEach(game=>{
          const card = createCard(game);
          listEl.appendChild(card);
        });
      }catch(err){
        listEl.innerHTML = `<div class="empty">Failed to load games: ${escapeHtml(err.message||String(err))}</div>`;
        console.error(err);
      }
    }

    load();
  </script>
</body>
</html>
